#!/usr/bin/env ruby

require 'optparse'
require 'sqlite3'

options = {}

opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: recipe_tracker COMMAND [OPTIONS]"
  opt.separator  ""
  opt.separator  "Commands"
  opt.separator  "     create: add a new recipe to database"
  opt.separator  ""
  opt.separator  "Options"

  # example where an option is followed by its own argument
  # the ALLCAPS is the option's argument
  opt.on("-i","--ingredients INGREDIENTS","ingredients in the recipe") do |ingredients|
    options[:ingredients] = ingredients
  end

  opt.on("-d","--directions DIRECTIONS","directions to prepare recipe") do |directions|
    options[:directions] = directions
  end

  opt.on("-t","--time TIME","estimated preparation time") do |time|
    options[:time] = time
  end

  opt.on("-m","--meal MEAL","type of recipe, e.g. entree") do |meal|
    options[:meal] = meal
  end

  opt.on("-s","--serves SERVES","number of people recipe serves") do |serves|
    options[:serves] = serves
  end

  opt.on("-c","--calories CALORIES","calories per serving") do |calories|
    options[:calories] = calories
  end

  opt.on("-o", "--test_output", "output for program testing") do |test_output|
    options[:test_output] = test_output
  end

  opt.on("-h","--help","help") do
    puts opt_parser
  end
end

# extracts options from ARGV, extracted value will be deleted from ARGV.
# this allows both of these command to work:
# ./spike3.rb start -e my_environment -d
# ./spike3.rb -e my_environment -d start
opt_parser.parse!

command = ARGV[0]
name = ARGV[1]

# Hard-coding a single database entry
puts "Hard-coding a Ham Sandwich entry to production database."
database = SQLite3::Database.new("db/recipe_tracker_production.sqlite3")
sql_statement = "INSERT INTO recipes VALUES ('Ham Sandwich', 'ham, cheese, bread', 'put between bread', 20, 'entree', 5, 40)"
database.execute(sql_statement)

if name.nil?
  puts "Please enter a recipe name."
  exit
end

required_options = [:ingredients, :directions, :time, :meal, :serves, :calories]
missing_options = required_options - options.keys

if missing_options.include?(:serves)
  index = missing_options.index(:serves)
  missing_options[index] = "number served"
end

unless missing_options.empty?
  puts "You must provide the #{missing_options.join(" and ")} of the recipe you are creating."
  exit
end

# this shows how you can route to different methods based on commands
# and options
# case ARGV[0]
# when "create"
#   puts "you entered create command with name #{name}, on options #{options.inspect}"
# else
#   puts opt_parser
# end

puts "Theoretically did: #{command} recipe #{name}; with ingredients #{options[:ingredients]}; with directions #{options[:directions]}; time #{options[:time]}; meal #{options[:meal]}; serves #{options[:serves]}; calories #{options[:calories]}." if options[:test_output]